
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>libics.func &#8212; libics 0.0dev documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">libics 0.0dev documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-libics.func">
<span id="libics-func"></span><h1>libics.func<a class="headerlink" href="#module-libics.func" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-libics.func.fit">
<span id="fit"></span><h2>fit<a class="headerlink" href="#module-libics.func.fit" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="libics.func.fit.FitParamBase">
<em class="property">class </em><code class="sig-prename descclassname">libics.func.fit.</code><code class="sig-name descname">FitParamBase</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">param</em>, <em class="sig-param">cov=0</em>, <em class="sig-param">param_names=None</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.fit.FitParamBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Base class for fitting. Contains fitting parameters and function calls.
Includes uncertainties.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><dl class="simple">
<dt>Fit function with call signature func(var, <a href="#id1"><span class="problematic" id="id2">*</span></a>param).</dt><dd><dl class="simple">
<dt>var<span class="classifier">scalar, np.ndarray</span></dt><dd><p>If array-like, the first dimension must accept
different independent parameters, i.e. (x, y, z, …).</p>
</dd>
<dt>param<span class="classifier">scalar</span></dt><dd><p>Fit parameters in the order as stored in this class.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><strong>param</strong><span class="classifier">np.ndarray(1) or int</span></dt><dd><p>If np.ndarray: used as current parameters.
If int: sets dimension of parameters (i.e. constructs an</p>
<blockquote>
<div><p>np.ndarray with <cite>param</cite> ones as elements).</p>
</div></blockquote>
</dd>
<dt><strong>cov</strong><span class="classifier">np.ndarray(2) or np.ndarray(1) or scalar</span></dt><dd><p>If np.ndarray(2): used as current covariance matrix.
If np.ndarray(1): used as current standard deviation. Off-diagonal</p>
<blockquote>
<div><p>elements are set to 0.</p>
</div></blockquote>
<p>If scalar: covariance matrix filled with given values.</p>
</dd>
<dt><strong>param_names</strong><span class="classifier">list(str) or None</span></dt><dd><p>List of unique parameter names.
If None, default names are index numbers.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>std</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(self, var, \*args, \*\*kwargs)</p></td>
<td><p>Calls and evaluates the function for the given variables.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#libics.func.fit.FitParamBase.find_fit" title="libics.func.fit.FitParamBase.find_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_fit</span></code></a>(self, var_data, func_data, \*\*kwargs)</p></td>
<td><p>Calculates the parameter fit using the parameter values as initial parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#libics.func.fit.FitParamBase.find_init_param" title="libics.func.fit.FitParamBase.find_init_param"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_init_param</span></code></a>(self, var_data, func_data)</p></td>
<td><p>Calculates the initial parameters and saves them as parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#libics.func.fit.FitParamBase.set_init_param" title="libics.func.fit.FitParamBase.set_init_param"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_init_param</span></code></a>(self, param)</p></td>
<td><p>Sets initial parameters and checks these for validity.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#libics.func.fit.FitParamBase.set_param_map" title="libics.func.fit.FitParamBase.set_param_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_param_map</span></code></a>(self, param_names)</p></td>
<td><p>Defines the parameter names and enables get by string.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="libics.func.fit.FitParamBase.find_fit">
<code class="sig-name descname">find_fit</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">var_data</em>, <em class="sig-param">func_data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.fit.FitParamBase.find_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the parameter fit using the parameter values
as initial parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>var_data</strong><span class="classifier">np.ndarray</span></dt><dd><p>Independent variable data to be fitted.
The first dimension must correspond to the function variable
input.</p>
</dd>
<dt><strong>func_data</strong><span class="classifier">np.ndarray</span></dt><dd><p>Dependent variable data (functional values) to be fitted.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Keyword arguments passed to scipy.optimize.curve_fit, i.a.:
sigma, absolute_sigma, check_finite, bounds, method, jac.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="libics.func.fit.FitParamBase.find_init_param">
<em class="property">abstract </em><code class="sig-name descname">find_init_param</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">var_data</em>, <em class="sig-param">func_data</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.fit.FitParamBase.find_init_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the initial parameters and saves them as parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>var_data</strong><span class="classifier">np.ndarray</span></dt><dd><p>Independent variable data to be fitted.
The first dimension must correspond to the function variable
input.</p>
</dd>
<dt><strong>func_data</strong><span class="classifier">np.ndarray</span></dt><dd><p>Dependent variable data (functional values) to be fitted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="libics.func.fit.FitParamBase.set_init_param">
<code class="sig-name descname">set_init_param</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">param</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.fit.FitParamBase.set_init_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets initial parameters and checks these for validity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>param</strong><span class="classifier">np.ndarray</span></dt><dd><p>Initial parameters used for fit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>ValueError</dt><dd><p>If parameter is invalid.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="libics.func.fit.FitParamBase.set_param_map">
<code class="sig-name descname">set_param_map</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">param_names</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.fit.FitParamBase.set_param_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the parameter names and enables get by string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>param_names</strong><span class="classifier">list(str)</span></dt><dd><p>List of unique parameter ID strings in the order
of the parameters.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="libics.func.fit.FitParamBase.std">
<em class="property">property </em><code class="sig-name descname">std</code><a class="headerlink" href="#libics.func.fit.FitParamBase.std" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="libics.func.fit.split_fit_data">
<code class="sig-prename descclassname">libics.func.fit.</code><code class="sig-name descname">split_fit_data</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">func_dim=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.fit.split_fit_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits the given data into independent and dependent data, as required
by the fit class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">arraydata.ArrayData or seriesdata.SeriesData or np.ndarray</span></dt><dd><p>Data to be split.</p>
</dd>
<dt><strong>func_dim</strong><span class="classifier">int</span></dt><dd><p>Only used for seriesdata.SeriesData.
Dependent data dimension (index).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>var_data</strong><span class="classifier">np.ndarray</span></dt><dd><p>Independent data.</p>
</dd>
<dt><strong>func_data</strong><span class="classifier">np.ndarray</span></dt><dd><p>Dependent data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-libics.func.flat">
<span id="flat"></span><h2>flat<a class="headerlink" href="#module-libics.func.flat" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="libics.func.flat.cosine_2d">
<code class="sig-prename descclassname">libics.func.flat.</code><code class="sig-name descname">cosine_2d</code><span class="sig-paren">(</span><em class="sig-param">var</em>, <em class="sig-param">amplitude_x</em>, <em class="sig-param">amplitude_y</em>, <em class="sig-param">period_x</em>, <em class="sig-param">period_y</em>, <em class="sig-param">phase_x</em>, <em class="sig-param">phase_y</em>, <em class="sig-param">offset=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.flat.cosine_2d" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-libics.func.peaked">
<span id="peaked"></span><h2>peaked<a class="headerlink" href="#module-libics.func.peaked" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="libics.func.peaked.FitAiryDisk2d">
<em class="property">class </em><code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">FitAiryDisk2d</code><span class="sig-paren">(</span><em class="sig-param">fit_offset=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.FitAiryDisk2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#libics.func.fit.FitParamBase" title="libics.func.fit.FitParamBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">libics.func.fit.FitParamBase</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>std</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(self, var, \*args, \*\*kwargs)</p></td>
<td><p>Calls and evaluates the function for the given variables.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_fit</span></code>(self, var_data, func_data, \*\*kwargs)</p></td>
<td><p>Calculates the parameter fit using the parameter values as initial parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#libics.func.peaked.FitAiryDisk2d.find_init_param" title="libics.func.peaked.FitAiryDisk2d.find_init_param"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_init_param</span></code></a>(self, var_data, func_data)</p></td>
<td><p>Algorithm: linear min/max approximation.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_init_param</span></code>(self, param)</p></td>
<td><p>Sets initial parameters and checks these for validity.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_param_map</span></code>(self, param_names)</p></td>
<td><p>Defines the parameter names and enables get by string.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="libics.func.peaked.FitAiryDisk2d.find_init_param">
<code class="sig-name descname">find_init_param</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">var_data</em>, <em class="sig-param">func_data</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.FitAiryDisk2d.find_init_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Algorithm: linear min/max approximation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="libics.func.peaked.FitGaussian2dTilt">
<em class="property">class </em><code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">FitGaussian2dTilt</code><span class="sig-paren">(</span><em class="sig-param">fit_offset=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.FitGaussian2dTilt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#libics.func.fit.FitParamBase" title="libics.func.fit.FitParamBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">libics.func.fit.FitParamBase</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>std</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(self, var, \*args, \*\*kwargs)</p></td>
<td><p>Calls and evaluates the function for the given variables.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_fit</span></code>(self, var_data, func_data, \*\*kwargs)</p></td>
<td><p>Calculates the parameter fit using the parameter values as initial parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#libics.func.peaked.FitGaussian2dTilt.find_init_param" title="libics.func.peaked.FitGaussian2dTilt.find_init_param"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_init_param</span></code></a>(self, var_data, func_data)</p></td>
<td><p>Algorithm: linear min/max approximation.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_init_param</span></code>(self, param)</p></td>
<td><p>Sets initial parameters and checks these for validity.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_param_map</span></code>(self, param_names)</p></td>
<td><p>Defines the parameter names and enables get by string.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="libics.func.peaked.FitGaussian2dTilt.find_init_param">
<code class="sig-name descname">find_init_param</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">var_data</em>, <em class="sig-param">func_data</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.FitGaussian2dTilt.find_init_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Algorithm: linear min/max approximation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="libics.func.peaked.FitLorentzian1dAbs">
<em class="property">class </em><code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">FitLorentzian1dAbs</code><span class="sig-paren">(</span><em class="sig-param">fit_offset=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.FitLorentzian1dAbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#libics.func.fit.FitParamBase" title="libics.func.fit.FitParamBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">libics.func.fit.FitParamBase</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>std</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(self, var, \*args, \*\*kwargs)</p></td>
<td><p>Calls and evaluates the function for the given variables.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_fit</span></code>(self, var_data, func_data, \*\*kwargs)</p></td>
<td><p>Calculates the parameter fit using the parameter values as initial parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#libics.func.peaked.FitLorentzian1dAbs.find_init_param" title="libics.func.peaked.FitLorentzian1dAbs.find_init_param"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_init_param</span></code></a>(self, var_data, func_data)</p></td>
<td><p>Algorithm: dummy max.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_init_param</span></code>(self, param)</p></td>
<td><p>Sets initial parameters and checks these for validity.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_param_map</span></code>(self, param_names)</p></td>
<td><p>Defines the parameter names and enables get by string.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="libics.func.peaked.FitLorentzian1dAbs.find_init_param">
<code class="sig-name descname">find_init_param</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">var_data</em>, <em class="sig-param">func_data</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.FitLorentzian1dAbs.find_init_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Algorithm: dummy max.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="libics.func.peaked.RndDscBallistic1d">
<em class="property">class </em><code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">RndDscBallistic1d</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">sites=(-100</em>, <em class="sig-param">100)</em>, <em class="sig-param">time=0</em>, <em class="sig-param">hopping=6.283185307179586</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.RndDscBallistic1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.stats._distn_infrastructure.rv_discrete</span></code></p>
<p>1D ballistic transport site occupation random variable.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>site</strong><span class="classifier"><cite>tuple(int)</cite></span></dt><dd><p>Minimum and maximum sites <cite>(site_min, site_max)</cite>.</p>
</dd>
<dt><strong>time</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Evolution time in seconds (s).</p>
</dd>
<dt><strong>hopping</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Hopping frequency in radians (rad).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">random_state</span></code></dt><dd><p>Get or set the RandomState object for generating random variates.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Freeze the distribution for the given arguments.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cdf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Cumulative distribution function of the given RV.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Differential entropy of the RV.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expect</span></code>(self[, func, args, loc, lb, ub, …])</p></td>
<td><p>Calculate expected value of a function with respect to the distribution for discrete distribution by numerical summation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">freeze</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Freeze the distribution for the given arguments.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interval</span></code>(self, alpha, \*args, \*\*kwds)</p></td>
<td><p>Confidence interval with equal areas around the median.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">isf</span></code>(self, q, \*args, \*\*kwds)</p></td>
<td><p>Inverse survival function (inverse of <cite>sf</cite>) at q of the given RV.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">logcdf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Log of the cumulative distribution function at k of the given RV.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">logpmf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Log of the probability mass function at k of the given RV.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">logsf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Log of the survival function of the given RV.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Mean of the distribution.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">median</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Median of the distribution.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment</span></code>(self, n, \*args, \*\*kwds)</p></td>
<td><p>n-th order non-central moment of distribution.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pmf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Probability mass function at k of the given RV.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ppf</span></code>(self, q, \*args, \*\*kwds)</p></td>
<td><p>Percent point function (inverse of <cite>cdf</cite>) at q of the given RV.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rvs</span></code>(self, \*args, \*\*kwargs)</p></td>
<td><p>Random variates of given type.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Survival function (1 - <cite>cdf</cite>) at k of the given RV.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">stats</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Some statistics of the given RV.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Standard deviation of the distribution.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">support</span></code>(self, \*args, \*\*kwargs)</p></td>
<td><p>Return the support of the distribution.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Variance of the distribution.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="libics.func.peaked.RndDscBlochOsc1d">
<em class="property">class </em><code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">RndDscBlochOsc1d</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">sites=(-100</em>, <em class="sig-param">100)</em>, <em class="sig-param">time=0</em>, <em class="sig-param">hopping=6.283185307179586</em>, <em class="sig-param">gradient=6.283185307179586</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.RndDscBlochOsc1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.stats._distn_infrastructure.rv_discrete</span></code></p>
<p>1D Bloch oscillation site occupation random variable.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>site</strong><span class="classifier"><cite>tuple(int)</cite></span></dt><dd><p>Minimum and maximum sites <cite>(site_min, site_max)</cite>.</p>
</dd>
<dt><strong>time</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Evolution time in seconds (s).</p>
</dd>
<dt><strong>hopping</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Hopping frequency in radians (rad).</p>
</dd>
<dt><strong>gradient</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Frequency difference between neighbouring sites in radians (rad).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">random_state</span></code></dt><dd><p>Get or set the RandomState object for generating random variates.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Freeze the distribution for the given arguments.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cdf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Cumulative distribution function of the given RV.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Differential entropy of the RV.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expect</span></code>(self[, func, args, loc, lb, ub, …])</p></td>
<td><p>Calculate expected value of a function with respect to the distribution for discrete distribution by numerical summation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">freeze</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Freeze the distribution for the given arguments.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interval</span></code>(self, alpha, \*args, \*\*kwds)</p></td>
<td><p>Confidence interval with equal areas around the median.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">isf</span></code>(self, q, \*args, \*\*kwds)</p></td>
<td><p>Inverse survival function (inverse of <cite>sf</cite>) at q of the given RV.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">logcdf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Log of the cumulative distribution function at k of the given RV.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">logpmf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Log of the probability mass function at k of the given RV.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">logsf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Log of the survival function of the given RV.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Mean of the distribution.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">median</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Median of the distribution.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment</span></code>(self, n, \*args, \*\*kwds)</p></td>
<td><p>n-th order non-central moment of distribution.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pmf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Probability mass function at k of the given RV.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ppf</span></code>(self, q, \*args, \*\*kwds)</p></td>
<td><p>Percent point function (inverse of <cite>cdf</cite>) at q of the given RV.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rvs</span></code>(self, \*args, \*\*kwargs)</p></td>
<td><p>Random variates of given type.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Survival function (1 - <cite>cdf</cite>) at k of the given RV.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">stats</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Some statistics of the given RV.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Standard deviation of the distribution.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">support</span></code>(self, \*args, \*\*kwargs)</p></td>
<td><p>Return the support of the distribution.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Variance of the distribution.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="libics.func.peaked.RndDscDiffusive1d">
<em class="property">class </em><code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">RndDscDiffusive1d</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">sites=(-100</em>, <em class="sig-param">100)</em>, <em class="sig-param">time=0</em>, <em class="sig-param">diffusion=1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.RndDscDiffusive1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.stats._distn_infrastructure.rv_discrete</span></code></p>
<p>1D random variable for diffusive transport on discrete sites.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>site</strong><span class="classifier"><cite>tuple(int)</cite></span></dt><dd><p>Minimum and maximum sites <cite>(site_min, site_max)</cite>.</p>
</dd>
<dt><strong>time</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Evolution time in seconds (s).</p>
</dd>
<dt><strong>diffusion</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Diffusion constant in sites² per second (1/s).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">random_state</span></code></dt><dd><p>Get or set the RandomState object for generating random variates.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Freeze the distribution for the given arguments.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cdf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Cumulative distribution function of the given RV.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Differential entropy of the RV.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expect</span></code>(self[, func, args, loc, lb, ub, …])</p></td>
<td><p>Calculate expected value of a function with respect to the distribution for discrete distribution by numerical summation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">freeze</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Freeze the distribution for the given arguments.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interval</span></code>(self, alpha, \*args, \*\*kwds)</p></td>
<td><p>Confidence interval with equal areas around the median.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">isf</span></code>(self, q, \*args, \*\*kwds)</p></td>
<td><p>Inverse survival function (inverse of <cite>sf</cite>) at q of the given RV.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">logcdf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Log of the cumulative distribution function at k of the given RV.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">logpmf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Log of the probability mass function at k of the given RV.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">logsf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Log of the survival function of the given RV.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Mean of the distribution.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">median</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Median of the distribution.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment</span></code>(self, n, \*args, \*\*kwds)</p></td>
<td><p>n-th order non-central moment of distribution.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pmf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Probability mass function at k of the given RV.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ppf</span></code>(self, q, \*args, \*\*kwds)</p></td>
<td><p>Percent point function (inverse of <cite>cdf</cite>) at q of the given RV.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rvs</span></code>(self, \*args, \*\*kwargs)</p></td>
<td><p>Random variates of given type.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sf</span></code>(self, k, \*args, \*\*kwds)</p></td>
<td><p>Survival function (1 - <cite>cdf</cite>) at k of the given RV.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">stats</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Some statistics of the given RV.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Standard deviation of the distribution.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">support</span></code>(self, \*args, \*\*kwargs)</p></td>
<td><p>Return the support of the distribution.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code>(self, \*args, \*\*kwds)</p></td>
<td><p>Variance of the distribution.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="libics.func.peaked.airy_disk_2d">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">airy_disk_2d</code><span class="sig-paren">(</span><em class="sig-param">var</em>, <em class="sig-param">amplitude</em>, <em class="sig-param">center_x</em>, <em class="sig-param">center_y</em>, <em class="sig-param">width</em>, <em class="sig-param">offset=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.airy_disk_2d" title="Permalink to this definition">¶</a></dt>
<dd><div class="math notranslate nohighlight">
\[A \left( \frac{2 J_1 \left( \sqrt{(x-x_0)^2 + (y-y_0)^2} / w \right)}
              {\sqrt{(x-x_0)^2 + (y-y_0)^2} / w} \right)^2 + C\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>`var` :math:`(x, y)`, `amplitude` :math:`A`,</strong></dt><dd></dd>
<dt><strong>`center_(x, y)` :math:`(x_0, y_0), `width` :math:`w`,</strong></dt><dd></dd>
<dt><strong>`offset` :math:`C`.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Handles limiting value at <span class="math notranslate nohighlight">\((x, y) -&gt; (0, 0)\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="libics.func.peaked.dsc_ballistic_1d">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">dsc_ballistic_1d</code><span class="sig-paren">(</span><em class="sig-param">var</em>, <em class="sig-param">hopping</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.dsc_ballistic_1d" title="Permalink to this definition">¶</a></dt>
<dd><div class="math notranslate nohighlight">
\[J_n^2 \left( 2 J t \right)\]</div>
<p>The hopping energy <span class="math notranslate nohighlight">\(J\)</span> should be given in <span class="math notranslate nohighlight">\(2 \pi\)</span> frequency
units, i.e. in units of <span class="math notranslate nohighlight">\(\hbar\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>`var` :math:`(n, t)`, `hopping` :math:`J`.</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>res</dt><dd><p>Probability distribution of 1D ballistic transport for the given
site <cite>var[0]</cite> at the given time <cite>var[1]</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.peaked.dsc_bloch_osc_1d">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">dsc_bloch_osc_1d</code><span class="sig-paren">(</span><em class="sig-param">var</em>, <em class="sig-param">hopping</em>, <em class="sig-param">gradient</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.dsc_bloch_osc_1d" title="Permalink to this definition">¶</a></dt>
<dd><div class="math notranslate nohighlight">
\[J_n^2 \left( \frac{4 J}{\Delta}
\cdot \left| \sin \frac{\Delta t}{2} \right| \right)\]</div>
<p><span class="math notranslate nohighlight">\(\Delta = F a\)</span> specifies the energy difference between neighbouring
sites with distance <span class="math notranslate nohighlight">\(a\)</span> at a potential gradient <span class="math notranslate nohighlight">\(F\)</span>.
Energies <span class="math notranslate nohighlight">\(J, \Delta\)</span> should be given in <span class="math notranslate nohighlight">\(2 \pi\)</span> frequency
units, i.e. in units of <span class="math notranslate nohighlight">\(\hbar\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>`var` :math:`(n, t)`, `hopping` :math:`J`, `gradient` :math:`Delta`.</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>res</dt><dd><p>Probability distribution of 1D Bloch oscillations for the given
site <cite>var[0]</cite> at the given time <cite>var[1]</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.peaked.dsc_bloch_osc_2d">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">dsc_bloch_osc_2d</code><span class="sig-paren">(</span><em class="sig-param">var</em>, <em class="sig-param">hopping_x</em>, <em class="sig-param">hopping_y</em>, <em class="sig-param">gradient_x</em>, <em class="sig-param">gradient_y</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.dsc_bloch_osc_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">bloch_osc_1d()</span></code>.</p>
<p><cite>var</cite> <span class="math notranslate nohighlight">\((n_x, n_y, t)\)</span></p>
</dd></dl>

<dl class="function">
<dt id="libics.func.peaked.dsc_bloch_osc_3d">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">dsc_bloch_osc_3d</code><span class="sig-paren">(</span><em class="sig-param">var</em>, <em class="sig-param">hopping_x</em>, <em class="sig-param">hopping_y</em>, <em class="sig-param">hopping_z</em>, <em class="sig-param">gradient_x</em>, <em class="sig-param">gradient_y</em>, <em class="sig-param">gradient_z</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.dsc_bloch_osc_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">bloch_osc_1d()</span></code>.</p>
<p><cite>var</cite> <span class="math notranslate nohighlight">\((n_x, n_y, n_z, t)\)</span></p>
</dd></dl>

<dl class="function">
<dt id="libics.func.peaked.dsc_diffusive_1d">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">dsc_diffusive_1d</code><span class="sig-paren">(</span><em class="sig-param">var</em>, <em class="sig-param">diffusion</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.dsc_diffusive_1d" title="Permalink to this definition">¶</a></dt>
<dd><div class="math notranslate nohighlight">
\[\frac{1}{\sqrt{4 \pi D t}}
\exp \left( -\frac{n^2}{4 D t} \right)\]</div>
<p>The diffusion constant <span class="math notranslate nohighlight">\(D\)</span> should be given in units of the
lattice constant <span class="math notranslate nohighlight">\(a\)</span>, i.e. <span class="math notranslate nohighlight">\(D_\text{SI} = D / a^2\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>`var` :math:`(n, t)`, `hopping` :math:`J`.</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>res</dt><dd><p>Probability distribution of 1D ballistic transport for the given
site <cite>var[0]</cite> at the given time <cite>var[1]</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.peaked.exponential_decay_1d">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">exponential_decay_1d</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">amplitude</em>, <em class="sig-param">center</em>, <em class="sig-param">length</em>, <em class="sig-param">offset=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.exponential_decay_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential decay in one dimension.</p>
<div class="math notranslate nohighlight">
\[A e^{-\frac{|x - c|}{\xi}} + C\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Variable <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Amplitude <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd>
<dt><strong>center</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Center <span class="math notranslate nohighlight">\(c\)</span>.</p>
</dd>
<dt><strong>length</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Characteristic length <span class="math notranslate nohighlight">\(\xi\)</span>.</p>
</dd>
<dt><strong>offset</strong><span class="classifier"><cite>float</cite>, optional (default: 0)</span></dt><dd><p>Offset <span class="math notranslate nohighlight">\(C\)</span></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.peaked.exponential_decay_nd">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">exponential_decay_nd</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">amplitude</em>, <em class="sig-param">center</em>, <em class="sig-param">length</em>, <em class="sig-param">offset=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.exponential_decay_nd" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential decay in <span class="math notranslate nohighlight">\(n\)</span> dimensions.</p>
<div class="math notranslate nohighlight">
\[A e^{-\sum_{i=1}^n \frac{|x_i - c_i|}{\xi_i}} + C\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><cite>numpy.array(n, float)</cite></span></dt><dd><p>Variables <span class="math notranslate nohighlight">\(x_i\)</span>.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Amplitude <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd>
<dt><strong>center</strong><span class="classifier"><cite>numpy.array(n, float)</cite></span></dt><dd><p>Centers <span class="math notranslate nohighlight">\(c_i\)</span>.</p>
</dd>
<dt><strong>length</strong><span class="classifier"><cite>numpy.array(n, float)</cite></span></dt><dd><p>Characteristic lengths <span class="math notranslate nohighlight">\(\xi_i\)</span>.</p>
</dd>
<dt><strong>offset</strong><span class="classifier"><cite>float</cite>, optional (default: 0)</span></dt><dd><p>Offset <span class="math notranslate nohighlight">\(C\)</span></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.peaked.gamma_distribution_1d">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">gamma_distribution_1d</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">amplitude</em>, <em class="sig-param">mean</em>, <em class="sig-param">number</em>, <em class="sig-param">offset=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.gamma_distribution_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Gamma distribution in one dimension.</p>
<div class="math notranslate nohighlight">
\[A \frac{(N / \mu)^N}{\Gamma (N)} x^{N - 1}
e^{-\frac{N}{\mu} x} + C\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Variable <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Amplitude <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd>
<dt><strong>mean</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Mean <span class="math notranslate nohighlight">\(\mu\)</span>.</p>
</dd>
<dt><strong>number</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Number <span class="math notranslate nohighlight">\(N\)</span>.</p>
</dd>
<dt><strong>offset</strong><span class="classifier"><cite>float</cite>, optional (default: 0)</span></dt><dd><p>Offset <span class="math notranslate nohighlight">\(C\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.peaked.gaussian_1d">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">gaussian_1d</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">amplitude</em>, <em class="sig-param">center</em>, <em class="sig-param">width</em>, <em class="sig-param">offset=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.gaussian_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussian in one dimension.</p>
<div class="math notranslate nohighlight">
\[A e^{-\frac{(x - c)^2}{2 \sigma^2}} + C\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Variable <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Amplitude <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd>
<dt><strong>center</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Center <span class="math notranslate nohighlight">\(c\)</span>.</p>
</dd>
<dt><strong>width</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Width <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
</dd>
<dt><strong>offset</strong><span class="classifier"><cite>float</cite>, optional (default: 0)</span></dt><dd><p>Offset <span class="math notranslate nohighlight">\(C\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.peaked.gaussian_2d_tilt">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">gaussian_2d_tilt</code><span class="sig-paren">(</span><em class="sig-param">var</em>, <em class="sig-param">amplitude</em>, <em class="sig-param">center_x</em>, <em class="sig-param">center_y</em>, <em class="sig-param">width_u</em>, <em class="sig-param">width_v</em>, <em class="sig-param">tilt</em>, <em class="sig-param">offset=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.gaussian_2d_tilt" title="Permalink to this definition">¶</a></dt>
<dd><p>Tilted (rotated) Gaussian in two dimensions.</p>
<div class="math notranslate nohighlight">
\[A e^{-\frac{((x - x_0) \cos \theta + (y - y_0) \sin \theta))^2}
           {2 \sigma_u^2}
     -\frac{((y - y_0) \cos \theta - (x - x_0) \sin \theta))^2}
           {2 \sigma_v^2}} + C\]</div>
<dl>
<dt>var<span class="classifier"><cite>numpy.array(2, float)</cite></span></dt><dd><p>Variables <span class="math notranslate nohighlight">\(x, y\)</span>.</p>
</dd>
<dt>amplitude<span class="classifier"><cite>float</cite></span></dt><dd><p>Amplitude <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd>
<dt>center_x, center_y<span class="classifier"><cite>float</cite></span></dt><dd><p>Centers <span class="math notranslate nohighlight">\(x_0, y_0\)</span>.</p>
</dd>
<dt>width_u, width_v<span class="classifier"><cite>float</cite></span></dt><dd><p>Widths <span class="math notranslate nohighlight">\(\sigma_u, \sigma_v\)</span>.</p>
</dd>
<dt>tilt<span class="classifier"><cite>float(0, numpy.pi)</cite></span></dt><dd><p>Tilt angle <span class="math notranslate nohighlight">\(\theta\)</span>.</p>
</dd>
<dt>offset<span class="classifier"><cite>float</cite>, optional (default: 0)</span></dt><dd><p>Offset <span class="math notranslate nohighlight">\(C\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.peaked.gaussian_nd">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">gaussian_nd</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">amplitude</em>, <em class="sig-param">center</em>, <em class="sig-param">width</em>, <em class="sig-param">offset=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.gaussian_nd" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussian in <span class="math notranslate nohighlight">\(n\)</span> dimensions.</p>
<div class="math notranslate nohighlight">
\[A e^{-\sum_{i=1}^n \left( \frac{x_i - c_i}{2 \sigma_i} \right)^2} + C\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><cite>numpy.array(n, float)</cite></span></dt><dd><p>Variables <span class="math notranslate nohighlight">\(x_i\)</span>.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Amplitude <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd>
<dt><strong>center</strong><span class="classifier"><cite>numpy.array(n, float)</cite></span></dt><dd><p>Centers <span class="math notranslate nohighlight">\(c_i\)</span>.</p>
</dd>
<dt><strong>width</strong><span class="classifier"><cite>numpy.array(n, float)</cite></span></dt><dd><p>Widths <span class="math notranslate nohighlight">\(\sigma_i\)</span>.</p>
</dd>
<dt><strong>offset</strong><span class="classifier"><cite>float</cite>, optional (default: 0)</span></dt><dd><p>Offset <span class="math notranslate nohighlight">\(C\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.peaked.gaussian_nd_centered">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">gaussian_nd_centered</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">amplitude</em>, <em class="sig-param">width</em>, <em class="sig-param">offset=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.gaussian_nd_centered" title="Permalink to this definition">¶</a></dt>
<dd><p>Centered Gaussian in <span class="math notranslate nohighlight">\(n\)</span> dimensions.</p>
<div class="math notranslate nohighlight">
\[A e^{-\sum_{i=1}^n \left( \frac{x_i}{2 \sigma_i} \right)^2} + C\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><cite>numpy.array(n, float)</cite></span></dt><dd><p>Variables <span class="math notranslate nohighlight">\(x_i\)</span>.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Amplitude <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd>
<dt><strong>width</strong><span class="classifier"><cite>numpy.array(n, float)</cite></span></dt><dd><p>Widths <span class="math notranslate nohighlight">\(\sigma_i\)</span>.</p>
</dd>
<dt><strong>offset</strong><span class="classifier"><cite>float</cite>, optional (default: 0)</span></dt><dd><p>Offset <span class="math notranslate nohighlight">\(C\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.peaked.gaussian_nd_symmetric">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">gaussian_nd_symmetric</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">amplitude</em>, <em class="sig-param">center</em>, <em class="sig-param">width</em>, <em class="sig-param">offset=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.gaussian_nd_symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Symmetric Gaussian in <span class="math notranslate nohighlight">\(n\)</span> dimensions.</p>
<div class="math notranslate nohighlight">
\[A e^{-\sum_{i=1}^n \left( \frac{x_i - c_i}{2 \sigma} \right)^2} + C\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><cite>numpy.array(n, float)</cite></span></dt><dd><p>Variables <span class="math notranslate nohighlight">\(x_i\)</span>.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier"><cite>float</cite></span></dt><dd><p>Amplitude <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd>
<dt><strong>center</strong><span class="classifier"><cite>numpy.array(n, float)</cite></span></dt><dd><p>Centers <span class="math notranslate nohighlight">\(c_i\)</span>.</p>
</dd>
<dt><strong>width</strong><span class="classifier"><cite>numpy.array(n, float)</cite></span></dt><dd><p>Width <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
</dd>
<dt><strong>offset</strong><span class="classifier"><cite>float</cite>, optional (default: 0)</span></dt><dd><p>Offset <span class="math notranslate nohighlight">\(C\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.peaked.lorentzian_1d_abs">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">lorentzian_1d_abs</code><span class="sig-paren">(</span><em class="sig-param">var</em>, <em class="sig-param">amplitude</em>, <em class="sig-param">center</em>, <em class="sig-param">width</em>, <em class="sig-param">offset=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.lorentzian_1d_abs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="libics.func.peaked.lorentzian_1d_complex">
<code class="sig-prename descclassname">libics.func.peaked.</code><code class="sig-name descname">lorentzian_1d_complex</code><span class="sig-paren">(</span><em class="sig-param">var</em>, <em class="sig-param">amplitude</em>, <em class="sig-param">center</em>, <em class="sig-param">width</em>, <em class="sig-param">offset=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.peaked.lorentzian_1d_complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-libics.func.tensor">
<span id="tensor"></span><h2>tensor<a class="headerlink" href="#module-libics.func.tensor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="libics.func.tensor.DiagonalizableLS">
<em class="property">class </em><code class="sig-prename descclassname">libics.func.tensor.</code><code class="sig-name descname">DiagonalizableLS</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#libics.func.tensor.LinearSystem" title="libics.func.tensor.LinearSystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">libics.func.tensor.LinearSystem</span></code></a></p>
<p>Eigensystem solver for arbitrary square diagonalizable matrices.</p>
<p>The linear system is defined as</p>
<div class="math notranslate nohighlight">
\[M x = y, x = \sum_p b_p m_p,\]</div>
<p>where <span class="math notranslate nohighlight">\(M\)</span> is the matrix, <span class="math notranslate nohighlight">\(x\)</span> is the solution vector,
<span class="math notranslate nohighlight">\(y\)</span> is the result vector, <span class="math notranslate nohighlight">\((\mu_p, m_p)\)</span> is the eigensystem
and <span class="math notranslate nohighlight">\(b_p\)</span> is the eigenvector decomposition.</p>
<p>If the matrix has additional properties, please use the subclasses
<a class="reference internal" href="#libics.func.tensor.HermitianLS" title="libics.func.tensor.HermitianLS"><code class="xref py py-class docutils literal notranslate"><span class="pre">HermitianLS</span></code></a> and <a class="reference internal" href="#libics.func.tensor.SymmetricLS" title="libics.func.tensor.SymmetricLS"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricLS</span></code></a>.</p>
<p class="rubric">Notes</p>
<p>Usage:</p>
<ul class="simple">
<li><p>Initialization: Set the matrix defining the linear system. Set the axes
for higher rank tensors.</p></li>
<li><p>Given the matrix <span class="math notranslate nohighlight">\(M\)</span>, this class allows for (1.) the calculation
of the eigensystem <span class="math notranslate nohighlight">\((\mu_p, m_p)\)</span>, (2.) solving for <span class="math notranslate nohighlight">\(x\)</span>,
and (3.) calculating the result <span class="math notranslate nohighlight">\(y\)</span>.</p></li>
</ul>
<ol class="arabic simple">
<li><p>Run <a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.calc_eigensystem" title="libics.func.tensor.DiagonalizableLS.calc_eigensystem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_eigensystem()</span></code></a> to calculate eigenvalues and
left/right eigenvectors.</p></li>
</ol>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>If the eigenvalues should be arranged meaningfully, they can be
ordered using <a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.sort_eigensystem" title="libics.func.tensor.DiagonalizableLS.sort_eigensystem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_eigensystem()</span></code></a>.</p></li>
<li><p>For non-symmetric and non-Hermitian matrices or for degenerate
eigenvalues, the eigenvectors are not orthogonal. A computationally
expensive orthonormalization can be obtained with
<a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.ortho_eigensystem" title="libics.func.tensor.DiagonalizableLS.ortho_eigensystem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ortho_eigensystem()</span></code></a>.</p></li>
</ol>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>Given the result vector <span class="math notranslate nohighlight">\(y\)</span>, there are two options to solve for
<span class="math notranslate nohighlight">\(x\)</span>.</p>
<ol class="loweralpha simple">
<li><p>If the eigensystem was calculated before, one can use
<a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.decomp_result" title="libics.func.tensor.DiagonalizableLS.decomp_result"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decomp_result()</span></code></a> to obtain the eigenvector decomposition.
Subsequently calling <a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.calc_solution" title="libics.func.tensor.DiagonalizableLS.calc_solution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_solution()</span></code></a> calculates the
solution vector <span class="math notranslate nohighlight">\(x\)</span>.</p></li>
<li><p>Alternatively, the solution can be obtained without eigensystem
decomposition with <code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code>, which only populates
the solution vector <span class="math notranslate nohighlight">\(x\)</span>.</p></li>
</ol>
</li>
<li><p>Given the solution vector <span class="math notranslate nohighlight">\(x\)</span>, there are two options to obtain
the result <span class="math notranslate nohighlight">\(y\)</span>.</p>
<ol class="loweralpha simple">
<li><p>If the eigensystem was calculated before, one can use
<a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.decomp_solution" title="libics.func.tensor.DiagonalizableLS.decomp_solution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decomp_solution()</span></code></a> to obtain the eigenvector
decomposition. Subsequently calling <a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.calc_result" title="libics.func.tensor.DiagonalizableLS.calc_result"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_result()</span></code></a>
calculates the result vector <span class="math notranslate nohighlight">\(y\)</span>.</p></li>
<li><p>Alternatively, the result can be obtained without eigensystem
decomposition with <code class="xref py py-meth docutils literal notranslate"><span class="pre">eval()</span></code>, which only populates
the result vector <span class="math notranslate nohighlight">\(y\)</span>.</p></li>
</ol>
</li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>decomp</strong></dt><dd></dd>
<dt><strong>eigvals</strong></dt><dd></dd>
<dt><strong>eigvecs</strong></dt><dd></dd>
<dt><strong>is_defective</strong></dt><dd></dd>
<dt><strong>is_diagonalizable</strong></dt><dd></dd>
<dt><a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.is_invertible" title="libics.func.tensor.DiagonalizableLS.is_invertible"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_invertible</span></code></a></dt><dd><p>Checks the rank of the matrix.</p>
</dd>
<dt><strong>is_singular</strong></dt><dd></dd>
<dt><strong>leigvecs</strong></dt><dd></dd>
<dt><strong>mata_axes</strong></dt><dd></dd>
<dt><strong>matb_axes</strong></dt><dd></dd>
<dt><strong>matrix</strong></dt><dd></dd>
<dt><strong>reigvecs</strong></dt><dd></dd>
<dt><strong>result</strong></dt><dd></dd>
<dt><strong>solution</strong></dt><dd></dd>
<dt><strong>vec_axes</strong></dt><dd></dd>
<dt><strong>veca_axes</strong></dt><dd></dd>
<dt><strong>vecb_axes</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.calc_eigensystem" title="libics.func.tensor.DiagonalizableLS.calc_eigensystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_eigensystem</span></code></a>(self)</p></td>
<td><p>Calculates eigenvalues, normalized left and right eigenvectors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.calc_result" title="libics.func.tensor.DiagonalizableLS.calc_result"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_result</span></code></a>(self[, decomp_vec])</p></td>
<td><p>Calculates the result vector <span class="math notranslate nohighlight">\(y\)</span> from a decomposition vector <span class="math notranslate nohighlight">\(b\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.calc_solution" title="libics.func.tensor.DiagonalizableLS.calc_solution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_solution</span></code></a>(self[, decomp_vec])</p></td>
<td><p>Calculates the solution vector <span class="math notranslate nohighlight">\(x\)</span> from a decomposition vector <span class="math notranslate nohighlight">\(b\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.decomp_result" title="libics.func.tensor.DiagonalizableLS.decomp_result"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decomp_result</span></code></a>(self[, res_vec])</p></td>
<td><p>Decomposes a result vector <span class="math notranslate nohighlight">\(y\)</span> into an overlap vector <span class="math notranslate nohighlight">\(b\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.decomp_solution" title="libics.func.tensor.DiagonalizableLS.decomp_solution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decomp_solution</span></code></a>(self[, sol_vec])</p></td>
<td><p>Decomposes a solution vector <span class="math notranslate nohighlight">\(x\)</span> into an overlap vector <span class="math notranslate nohighlight">\(b\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code>(self[, sol_vec])</p></td>
<td><p>For a given solution vector <span class="math notranslate nohighlight">\(x\)</span>, directly evaluates the result vector <span class="math notranslate nohighlight">\(y\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.ortho_eigensystem" title="libics.func.tensor.DiagonalizableLS.ortho_eigensystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ortho_eigensystem</span></code></a>(self)</p></td>
<td><p>Orthonormalizes the eigenvectors.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve</span></code>(self[, res_vec, algorithm])</p></td>
<td><p>For a given result vector <span class="math notranslate nohighlight">\(y\)</span>, directly solves for the solution vector <span class="math notranslate nohighlight">\(x\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.sort_eigensystem" title="libics.func.tensor.DiagonalizableLS.sort_eigensystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_eigensystem</span></code></a>(self[, order])</p></td>
<td><p>Sorts the eigensystem according to the given order.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.calc_eigensystem">
<code class="sig-name descname">calc_eigensystem</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.calc_eigensystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates eigenvalues, normalized left and right eigenvectors.</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The eigenvalues are in no guaranteed order.
See <a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.sort_eigensystem" title="libics.func.tensor.DiagonalizableLS.sort_eigensystem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_eigensystem()</span></code></a>.</p></li>
<li><p>The eigenvectors are not necessarily orthogonal.
See <a class="reference internal" href="#libics.func.tensor.DiagonalizableLS.ortho_eigensystem" title="libics.func.tensor.DiagonalizableLS.ortho_eigensystem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ortho_eigensystem()</span></code></a>.</p></li>
</ul>
</dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.calc_result">
<code class="sig-name descname">calc_result</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">decomp_vec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.calc_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the result vector <span class="math notranslate nohighlight">\(y\)</span> from a decomposition vector
<span class="math notranslate nohighlight">\(b\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.calc_solution">
<code class="sig-name descname">calc_solution</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">decomp_vec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.calc_solution" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the solution vector <span class="math notranslate nohighlight">\(x\)</span> from a decomposition vector
<span class="math notranslate nohighlight">\(b\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.decomp">
<em class="property">property </em><code class="sig-name descname">decomp</code><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.decomp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.decomp_result">
<code class="sig-name descname">decomp_result</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">res_vec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.decomp_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Decomposes a result vector <span class="math notranslate nohighlight">\(y\)</span> into an overlap vector <span class="math notranslate nohighlight">\(b\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.decomp_solution">
<code class="sig-name descname">decomp_solution</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">sol_vec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.decomp_solution" title="Permalink to this definition">¶</a></dt>
<dd><p>Decomposes a solution vector <span class="math notranslate nohighlight">\(x\)</span> into an overlap vector
<span class="math notranslate nohighlight">\(b\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.eigvals">
<em class="property">property </em><code class="sig-name descname">eigvals</code><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.eigvals" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.eigvecs">
<em class="property">property </em><code class="sig-name descname">eigvecs</code><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.eigvecs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.is_defective">
<em class="property">property </em><code class="sig-name descname">is_defective</code><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.is_defective" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.is_diagonalizable">
<em class="property">property </em><code class="sig-name descname">is_diagonalizable</code><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.is_diagonalizable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.is_invertible">
<em class="property">property </em><code class="sig-name descname">is_invertible</code><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks the rank of the matrix. Can be computationally expensive!</p>
</dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.is_singular">
<em class="property">property </em><code class="sig-name descname">is_singular</code><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.is_singular" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.leigvecs">
<em class="property">property </em><code class="sig-name descname">leigvecs</code><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.leigvecs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.matrix">
<em class="property">property </em><code class="sig-name descname">matrix</code><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.ortho_eigensystem">
<code class="sig-name descname">ortho_eigensystem</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.ortho_eigensystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthonormalizes the eigenvectors.</p>
</dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.reigvecs">
<em class="property">property </em><code class="sig-name descname">reigvecs</code><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.reigvecs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.DiagonalizableLS.sort_eigensystem">
<code class="sig-name descname">sort_eigensystem</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.DiagonalizableLS.sort_eigensystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the eigensystem according to the given order.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>order</strong><span class="classifier"><cite>np.ndarray</cite> or <cite>callable</cite> or <cite>None</cite></span></dt><dd><dl class="simple">
<dt><cite>np.ndarray</cite>:</dt><dd><p>Index order defined by this array.
Dimensions: [n_dof].</p>
</dd>
<dt><cite>callable</cite>:</dt><dd><p>Eigenvalue measurement function whose ascendingly sorted
return value defines the index order.
Call signature: <cite>func(np.ndarray(…, n_dof))-&gt;float</cite>.</p>
</dd>
<dt><cite>None</cite>:</dt><dd><p>Index order ascending in modulus of eigenvalue.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="libics.func.tensor.HermitianLS">
<em class="property">class </em><code class="sig-prename descclassname">libics.func.tensor.</code><code class="sig-name descname">HermitianLS</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.HermitianLS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#libics.func.tensor.DiagonalizableLS" title="libics.func.tensor.DiagonalizableLS"><code class="xref py py-class docutils literal notranslate"><span class="pre">libics.func.tensor.DiagonalizableLS</span></code></a></p>
<p>Eigensystem solver for Hermitian diagonalizable matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>decomp</strong></dt><dd></dd>
<dt><strong>eigvals</strong></dt><dd></dd>
<dt><strong>eigvecs</strong></dt><dd></dd>
<dt><strong>is_defective</strong></dt><dd></dd>
<dt><strong>is_diagonalizable</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_invertible</span></code></dt><dd><p>Checks the rank of the matrix.</p>
</dd>
<dt><strong>is_singular</strong></dt><dd></dd>
<dt><strong>leigvecs</strong></dt><dd></dd>
<dt><strong>mata_axes</strong></dt><dd></dd>
<dt><strong>matb_axes</strong></dt><dd></dd>
<dt><strong>matrix</strong></dt><dd></dd>
<dt><strong>reigvecs</strong></dt><dd></dd>
<dt><strong>result</strong></dt><dd></dd>
<dt><strong>solution</strong></dt><dd></dd>
<dt><strong>vec_axes</strong></dt><dd></dd>
<dt><strong>veca_axes</strong></dt><dd></dd>
<dt><strong>vecb_axes</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#libics.func.tensor.HermitianLS.calc_eigensystem" title="libics.func.tensor.HermitianLS.calc_eigensystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_eigensystem</span></code></a>(self)</p></td>
<td><p>Calculates eigenvalues, normalized left and right eigenvectors.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_result</span></code>(self[, decomp_vec])</p></td>
<td><p>Calculates the result vector <span class="math notranslate nohighlight">\(y\)</span> from a decomposition vector <span class="math notranslate nohighlight">\(b\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_solution</span></code>(self[, decomp_vec])</p></td>
<td><p>Calculates the solution vector <span class="math notranslate nohighlight">\(x\)</span> from a decomposition vector <span class="math notranslate nohighlight">\(b\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">decomp_result</span></code>(self[, res_vec])</p></td>
<td><p>Decomposes a result vector <span class="math notranslate nohighlight">\(y\)</span> into an overlap vector <span class="math notranslate nohighlight">\(b\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">decomp_solution</span></code>(self[, sol_vec])</p></td>
<td><p>Decomposes a solution vector <span class="math notranslate nohighlight">\(x\)</span> into an overlap vector <span class="math notranslate nohighlight">\(b\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code>(self[, sol_vec])</p></td>
<td><p>For a given solution vector <span class="math notranslate nohighlight">\(x\)</span>, directly evaluates the result vector <span class="math notranslate nohighlight">\(y\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ortho_eigensystem</span></code>(self)</p></td>
<td><p>Orthonormalizes the eigenvectors.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve</span></code>(self[, res_vec, algorithm])</p></td>
<td><p>For a given result vector <span class="math notranslate nohighlight">\(y\)</span>, directly solves for the solution vector <span class="math notranslate nohighlight">\(x\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_eigensystem</span></code>(self[, order])</p></td>
<td><p>Sorts the eigensystem according to the given order.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="libics.func.tensor.HermitianLS.calc_eigensystem">
<code class="sig-name descname">calc_eigensystem</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.HermitianLS.calc_eigensystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates eigenvalues, normalized left and right eigenvectors.</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The eigenvalues are in no guaranteed order.
See <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_eigensystem()</span></code>.</p></li>
<li><p>The eigenvectors are not necessarily orthogonal.
See <code class="xref py py-meth docutils literal notranslate"><span class="pre">ortho_eigensystem()</span></code>.</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="libics.func.tensor.LinearSystem">
<em class="property">class </em><code class="sig-prename descclassname">libics.func.tensor.</code><code class="sig-name descname">LinearSystem</code><span class="sig-paren">(</span><em class="sig-param">matrix=None</em>, <em class="sig-param">mata_axes=-2</em>, <em class="sig-param">matb_axes=-1</em>, <em class="sig-param">veca_axes=-1</em>, <em class="sig-param">vecb_axes=-1</em>, <em class="sig-param">vec_axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.LinearSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Linear system solver for arbitrary complex matrices.</p>
<p>The linear system is defined as</p>
<div class="math notranslate nohighlight">
\[M x = y,\]</div>
<p>where <span class="math notranslate nohighlight">\(M\)</span> is the matrix, <span class="math notranslate nohighlight">\(x\)</span> is the solution vector, and
<span class="math notranslate nohighlight">\(y\)</span> is the result vector.</p>
<p>For a given matrix <span class="math notranslate nohighlight">\(M\)</span> and solution vector <span class="math notranslate nohighlight">\(x\)</span>, this class
supports evaluation of <span class="math notranslate nohighlight">\(y\)</span>. If <span class="math notranslate nohighlight">\(y\)</span> is given, the system
supports direct solving for <span class="math notranslate nohighlight">\(x\)</span>. The matrix and vector dimensions
can consist of multiple indices which are automatically linearized.
For an eigensystem solver, refer to <a class="reference internal" href="#libics.func.tensor.DiagonalizableLS" title="libics.func.tensor.DiagonalizableLS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiagonalizableLS</span></code></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>matrix</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Possibly high rank tensor representable as diagonalizable
matrix, defining a linear system. There must be two sets of
dimensions which can be reshaped as square matrix. The remaining
dimensions will be broadcasted.</p>
</dd>
<dt><strong>mata_axes, matb_axes, veca_axes, veca_bxes</strong><span class="classifier"><cite>tuple(int)</cite></span></dt><dd><p>Axes representing the multidimensional indices of the matrix.
<span class="math notranslate nohighlight">\(M = M_{\{a_1, ...\}, \{b_1, ...\}}, x, y = x, y_{\{v_1, ...\}}\)</span>.
<span class="math notranslate nohighlight">\(M x = y = \sum_b M_{a, b} x_b = y_a\)</span>.
The shape of each dimension must be identical and the total number
defines the degrees of freedom <span class="math notranslate nohighlight">\(n_{\text{dof}} = \prod_i n_i\)</span>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mata_axes</strong></dt><dd></dd>
<dt><strong>matb_axes</strong></dt><dd></dd>
<dt><strong>matrix</strong></dt><dd></dd>
<dt><strong>result</strong></dt><dd></dd>
<dt><strong>solution</strong></dt><dd></dd>
<dt><strong>vec_axes</strong></dt><dd></dd>
<dt><strong>veca_axes</strong></dt><dd></dd>
<dt><strong>vecb_axes</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#libics.func.tensor.LinearSystem.eval" title="libics.func.tensor.LinearSystem.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code></a>(self[, sol_vec])</p></td>
<td><p>For a given solution vector <span class="math notranslate nohighlight">\(x\)</span>, directly evaluates the result vector <span class="math notranslate nohighlight">\(y\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#libics.func.tensor.LinearSystem.solve" title="libics.func.tensor.LinearSystem.solve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve</span></code></a>(self[, res_vec, algorithm])</p></td>
<td><p>For a given result vector <span class="math notranslate nohighlight">\(y\)</span>, directly solves for the solution vector <span class="math notranslate nohighlight">\(x\)</span>.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="libics.func.tensor.LinearSystem.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">sol_vec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.LinearSystem.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given solution vector <span class="math notranslate nohighlight">\(x\)</span>, directly evaluates the result
vector <span class="math notranslate nohighlight">\(y\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="libics.func.tensor.LinearSystem.mata_axes">
<em class="property">property </em><code class="sig-name descname">mata_axes</code><a class="headerlink" href="#libics.func.tensor.LinearSystem.mata_axes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.LinearSystem.matb_axes">
<em class="property">property </em><code class="sig-name descname">matb_axes</code><a class="headerlink" href="#libics.func.tensor.LinearSystem.matb_axes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.LinearSystem.matrix">
<em class="property">property </em><code class="sig-name descname">matrix</code><a class="headerlink" href="#libics.func.tensor.LinearSystem.matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.LinearSystem.result">
<em class="property">property </em><code class="sig-name descname">result</code><a class="headerlink" href="#libics.func.tensor.LinearSystem.result" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.LinearSystem.solution">
<em class="property">property </em><code class="sig-name descname">solution</code><a class="headerlink" href="#libics.func.tensor.LinearSystem.solution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.LinearSystem.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">res_vec=None</em>, <em class="sig-param">algorithm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.LinearSystem.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given result vector <span class="math notranslate nohighlight">\(y\)</span>, directly solves for the solution
vector <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="libics.func.tensor.LinearSystem.vec_axes">
<em class="property">property </em><code class="sig-name descname">vec_axes</code><a class="headerlink" href="#libics.func.tensor.LinearSystem.vec_axes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.LinearSystem.veca_axes">
<em class="property">property </em><code class="sig-name descname">veca_axes</code><a class="headerlink" href="#libics.func.tensor.LinearSystem.veca_axes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="libics.func.tensor.LinearSystem.vecb_axes">
<em class="property">property </em><code class="sig-name descname">vecb_axes</code><a class="headerlink" href="#libics.func.tensor.LinearSystem.vecb_axes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="libics.func.tensor.SymmetricLS">
<em class="property">class </em><code class="sig-prename descclassname">libics.func.tensor.</code><code class="sig-name descname">SymmetricLS</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.SymmetricLS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#libics.func.tensor.DiagonalizableLS" title="libics.func.tensor.DiagonalizableLS"><code class="xref py py-class docutils literal notranslate"><span class="pre">libics.func.tensor.DiagonalizableLS</span></code></a></p>
<p>Eigensystem solver for complex symmetric diagonalizable matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>decomp</strong></dt><dd></dd>
<dt><strong>eigvals</strong></dt><dd></dd>
<dt><strong>eigvecs</strong></dt><dd></dd>
<dt><strong>is_defective</strong></dt><dd></dd>
<dt><strong>is_diagonalizable</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_invertible</span></code></dt><dd><p>Checks the rank of the matrix.</p>
</dd>
<dt><strong>is_singular</strong></dt><dd></dd>
<dt><strong>leigvecs</strong></dt><dd></dd>
<dt><strong>mata_axes</strong></dt><dd></dd>
<dt><strong>matb_axes</strong></dt><dd></dd>
<dt><strong>matrix</strong></dt><dd></dd>
<dt><strong>reigvecs</strong></dt><dd></dd>
<dt><strong>result</strong></dt><dd></dd>
<dt><strong>solution</strong></dt><dd></dd>
<dt><strong>vec_axes</strong></dt><dd></dd>
<dt><strong>veca_axes</strong></dt><dd></dd>
<dt><strong>vecb_axes</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#libics.func.tensor.SymmetricLS.calc_eigensystem" title="libics.func.tensor.SymmetricLS.calc_eigensystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_eigensystem</span></code></a>(self)</p></td>
<td><p>Calculates eigenvalues, normalized left and right eigenvectors.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_result</span></code>(self[, decomp_vec])</p></td>
<td><p>Calculates the result vector <span class="math notranslate nohighlight">\(y\)</span> from a decomposition vector <span class="math notranslate nohighlight">\(b\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_solution</span></code>(self[, decomp_vec])</p></td>
<td><p>Calculates the solution vector <span class="math notranslate nohighlight">\(x\)</span> from a decomposition vector <span class="math notranslate nohighlight">\(b\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">decomp_result</span></code>(self[, res_vec])</p></td>
<td><p>Decomposes a result vector <span class="math notranslate nohighlight">\(y\)</span> into an overlap vector <span class="math notranslate nohighlight">\(b\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">decomp_solution</span></code>(self[, sol_vec])</p></td>
<td><p>Decomposes a solution vector <span class="math notranslate nohighlight">\(x\)</span> into an overlap vector <span class="math notranslate nohighlight">\(b\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code>(self[, sol_vec])</p></td>
<td><p>For a given solution vector <span class="math notranslate nohighlight">\(x\)</span>, directly evaluates the result vector <span class="math notranslate nohighlight">\(y\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ortho_eigensystem</span></code>(self)</p></td>
<td><p>Orthonormalizes the eigenvectors.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve</span></code>(self[, res_vec, algorithm])</p></td>
<td><p>For a given result vector <span class="math notranslate nohighlight">\(y\)</span>, directly solves for the solution vector <span class="math notranslate nohighlight">\(x\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_eigensystem</span></code>(self[, order])</p></td>
<td><p>Sorts the eigensystem according to the given order.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="libics.func.tensor.SymmetricLS.calc_eigensystem">
<code class="sig-name descname">calc_eigensystem</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.SymmetricLS.calc_eigensystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates eigenvalues, normalized left and right eigenvectors.</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The eigenvalues are in no guaranteed order.
See <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_eigensystem()</span></code>.</p></li>
<li><p>The eigenvectors are not necessarily orthogonal.
See <code class="xref py py-meth docutils literal notranslate"><span class="pre">ortho_eigensystem()</span></code>.</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="libics.func.tensor.complex_norm">
<code class="sig-prename descclassname">libics.func.tensor.</code><code class="sig-name descname">complex_norm</code><span class="sig-paren">(</span><em class="sig-param">ar</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.complex_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the pseudonorm <span class="math notranslate nohighlight">\(\sqrt{x^T x}\)</span> on the complex (tensorial)
vector <span class="math notranslate nohighlight">\(x\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ar</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Array constituting the vector to be normalized.</p>
</dd>
<dt><strong>axis</strong><span class="classifier"><cite>tuple(int)</cite></span></dt><dd><p>Tensorial indices corresponding to the vectorial dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>norm</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Resulting norm with removed vectorial axes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.tensor.euclid_norm">
<code class="sig-prename descclassname">libics.func.tensor.</code><code class="sig-name descname">euclid_norm</code><span class="sig-paren">(</span><em class="sig-param">ar</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.euclid_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Euclidean norm <span class="math notranslate nohighlight">\(\sqrt{x^\dagger x}\)</span> on the complex
(tensorial) vector <span class="math notranslate nohighlight">\(x\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ar</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Array constituting the vector to be normalized.</p>
</dd>
<dt><strong>axis</strong><span class="classifier"><cite>tuple(int)</cite></span></dt><dd><p>Tensorial indices corresponding to the vectorial dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>norm</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Resulting norm with removed vectorial axes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.tensor.ortho_gram_schmidt">
<code class="sig-prename descclassname">libics.func.tensor.</code><code class="sig-name descname">ortho_gram_schmidt</code><span class="sig-paren">(</span><em class="sig-param">vectors</em>, <em class="sig-param">norm_func=&lt;function norm at 0x0000015F3535EEA0&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.ortho_gram_schmidt" title="Permalink to this definition">¶</a></dt>
<dd><p>Naive Gram-Schmidt orthogonalization.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>vectors</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Normalized, linearly independent row vectors to be orthonormalized.
Dimensions: [n_vector, n_components].</p>
</dd>
<dt><strong>norm</strong><span class="classifier"><cite>callable</cite></span></dt><dd><p>Function computing a vector norm.
Call signature: <cite>norm_func(vector)-&gt;scalar</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>basis</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Orthonormal basis of space spanned by <cite>vectors</cite>.
Dimensions: [n_vector, n_components].</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.tensor.tensorinv_numpy_array">
<code class="sig-prename descclassname">libics.func.tensor.</code><code class="sig-name descname">tensorinv_numpy_array</code><span class="sig-paren">(</span><em class="sig-param">ar</em>, <em class="sig-param">a_axes=-2</em>, <em class="sig-param">b_axes=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.tensorinv_numpy_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the tensor inverse (w.r.t. to <a class="reference internal" href="#libics.func.tensor.tensormul_numpy_array" title="libics.func.tensor.tensormul_numpy_array"><code class="xref py py-func docutils literal notranslate"><span class="pre">tensormul_numpy_array()</span></code></a>).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ar</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Full tensor.</p>
</dd>
<dt><strong>a_axes, b_axes</strong><span class="classifier"><cite>tuple(int)</cite></span></dt><dd><p>Corresponding dimensions to be inverted.
These specified dimensions span an effective square matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>ar</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Inverted full tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.tensor.tensorize_numpy_array">
<code class="sig-prename descclassname">libics.func.tensor.</code><code class="sig-name descname">tensorize_numpy_array</code><span class="sig-paren">(</span><em class="sig-param">vec</em>, <em class="sig-param">tensor_shape</em>, <em class="sig-param">tensor_axes=(-2</em>, <em class="sig-param">-1)</em>, <em class="sig-param">vec_axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.tensorize_numpy_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Tensorizes a vectorized <cite>numpy</cite> array. Opposite of
<a class="reference internal" href="#libics.func.tensor.vectorize_numpy_array" title="libics.func.tensor.vectorize_numpy_array"><code class="xref py py-func docutils literal notranslate"><span class="pre">vectorize_numpy_array()</span></code></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>vec</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Vector array.</p>
</dd>
<dt><strong>tensor_shape</strong><span class="classifier"><cite>tuple(int)</cite></span></dt><dd><p>Shape of tensorized dimensions.</p>
</dd>
<dt><strong>tensor_axes</strong><span class="classifier"><cite>tuple(int)</cite></span></dt><dd><p>Tensor axes of resulting array. Tensorization is performed
in C-like order.</p>
</dd>
<dt><strong>vec_axis</strong><span class="classifier"><cite>int</cite></span></dt><dd><p>Dimension of vector array to be tensorized.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>ar</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Tensor array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.tensor.tensormul_numpy_array">
<code class="sig-prename descclassname">libics.func.tensor.</code><code class="sig-name descname">tensormul_numpy_array</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">a_axes=(Ellipsis</em>, <em class="sig-param">0)</em>, <em class="sig-param">b_axes=(0</em>, <em class="sig-param">Ellipsis)</em>, <em class="sig-param">res_axes=(Ellipsis</em>, <em class="sig-param">)</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.tensormul_numpy_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Einstein-sums two <cite>numpy</cite> tensors.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a, b</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Tensor operands.</p>
</dd>
<dt><strong>a_axes, b_axes, res_axes</strong><span class="classifier"><cite>tuple(int)</cite></span></dt><dd><p>Indices of Einstein summation. Dimensions are interpreted
relative. Allows for use of ellipses.
<cite>res_axes</cite> allows for <cite>None</cite> to obtain a scalar.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>res</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Combined result tensor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function wraps <cite>numpy.einsum</cite>.</p>
<p class="rubric">Examples</p>
<p>Denote: (a_axes), (b_axes) -&gt; (res_axes) [<cite>np.einsum</cite> string]</p>
<ul class="simple">
<li><p>Matrix multiplication: e.g.
(0, 1), (1, 2) -&gt; (0, 2) [“ij,jk-&gt;ik”].</p></li>
<li><p>Tensor dot: e.g.
(0, 1, 2, 3), (4, 2, 3, 5) -&gt; (0, 1, 4, 5) [“ijkl,mjkn-&gt;ilmn”].</p></li>
<li><p>Tensor dot with broadcasting: e.g.
(0, 1, 2, 3), (0, 1, 2, 3) -&gt; (0, 3) [“ijkl,ijkl-&gt;il”].</p></li>
</ul>
</dd></dl>

<dl class="function">
<dt id="libics.func.tensor.tensorsolve_numpy_array">
<code class="sig-prename descclassname">libics.func.tensor.</code><code class="sig-name descname">tensorsolve_numpy_array</code><span class="sig-paren">(</span><em class="sig-param">ar</em>, <em class="sig-param">res</em>, <em class="sig-param">a_axes=-2</em>, <em class="sig-param">b_axes=-1</em>, <em class="sig-param">res_axes=-1</em>, <em class="sig-param">algorithm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.tensorsolve_numpy_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a tensor equation <span class="math notranslate nohighlight">\(A x = b\)</span> for <span class="math notranslate nohighlight">\(x\)</span>, where all operands
may be high-dimensional.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ar</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Matrix tensor <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd>
<dt><strong>res</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Vector tensor <span class="math notranslate nohighlight">\(b\)</span>.</p>
</dd>
<dt><strong>a_axes, b_axes, res_axes</strong><span class="classifier"><cite>tuple(int)</cite></span></dt><dd><p>Tensorial indices corresponding to
<span class="math notranslate nohighlight">\(\sum_{b} A_{ab} x_b = y_{res}\)</span>.</p>
</dd>
<dt><strong>algorithm</strong><span class="classifier"><cite>None</cite> or <cite>str</cite></span></dt><dd><p><cite>None</cite> or <a href="#id3"><span class="problematic" id="id4">`</span></a>”lu_fac”: LU factorization.
<a href="#id5"><span class="problematic" id="id6">`</span></a>”lst_sq”: least squares optimization.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>sol</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Solution vector tensor <span class="math notranslate nohighlight">\(x\)</span> with solution indices res_axes.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Tries to solve the linear equation using a deterministic full-rank solver.
If this fails, a least-squares algorithm is used. The least-squares solver
does not support broadcasting.</p>
</dd></dl>

<dl class="function">
<dt id="libics.func.tensor.tensortranspose_numpy_array">
<code class="sig-prename descclassname">libics.func.tensor.</code><code class="sig-name descname">tensortranspose_numpy_array</code><span class="sig-paren">(</span><em class="sig-param">ar</em>, <em class="sig-param">a_axes=-2</em>, <em class="sig-param">b_axes=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.tensortranspose_numpy_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Transposes the matrix spanned by <cite>a_axes</cite>, <cite>b_axes</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ar</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Full tensor.</p>
</dd>
<dt><strong>a_axes, b_axes</strong><span class="classifier"><cite>tuple(int)</cite></span></dt><dd><p>Corresponding dimensions to be transposed.
These specified dimensions span an effective square matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>ar</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Transposed full tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="libics.func.tensor.vectorize_numpy_array">
<code class="sig-prename descclassname">libics.func.tensor.</code><code class="sig-name descname">vectorize_numpy_array</code><span class="sig-paren">(</span><em class="sig-param">ar</em>, <em class="sig-param">tensor_axes=(-2</em>, <em class="sig-param">-1)</em>, <em class="sig-param">vec_axis=-1</em>, <em class="sig-param">ret_shape=False</em><span class="sig-paren">)</span><a class="headerlink" href="#libics.func.tensor.vectorize_numpy_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Vectorizes a tensor (high-dimensional) <cite>numpy</cite> array. Opposite of
<a class="reference internal" href="#libics.func.tensor.tensorize_numpy_array" title="libics.func.tensor.tensorize_numpy_array"><code class="xref py py-func docutils literal notranslate"><span class="pre">tensorize_numpy_array()</span></code></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ar</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Tensor array.</p>
</dd>
<dt><strong>tensor_axes</strong><span class="classifier"><cite>tuple(int)</cite></span></dt><dd><p>Tensor axes to be vectorized. Vectorization is performed
in C-like order.</p>
</dd>
<dt><strong>vec_axis</strong><span class="classifier"><cite>int</cite></span></dt><dd><p>Vectorized dimension of resulting vector array.</p>
</dd>
<dt><strong>ret_shape</strong><span class="classifier"><cite>bool</cite></span></dt><dd><p>Flag whether to return the shape of the vectorized dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>vec</strong><span class="classifier"><cite>np.ndarray</cite></span></dt><dd><p>Vector array.</p>
</dd>
<dt><strong>vec_shape</strong><span class="classifier"><cite>tuple(int)</cite></span></dt><dd><p>If ret_shape is set: shape of vectorized dimensions.
Useful as parameter for tensorization.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Performance is maximal for back-aligned, ordered vectorization since
in-place data ordering is possible.</p>
<p class="rubric">Examples</p>
<p>Given a tensor A[i, j, k, l], required is a vectorized version
A[i, j*k, l]. The corresponding call would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">j</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">l</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3, 4, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">vectorize_numpy_array</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tensor_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">vec_axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 12, 5)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">libics.func</a><ul>
<li><a class="reference internal" href="#module-libics.func.fit">fit</a></li>
<li><a class="reference internal" href="#module-libics.func.flat">flat</a></li>
<li><a class="reference internal" href="#module-libics.func.peaked">peaked</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#module-libics.func.tensor">tensor</a><ul>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/_dynamic/libics.func.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">libics 0.0dev documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, David Wei.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>